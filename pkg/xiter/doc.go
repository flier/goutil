// Package xiter provides utilities for enhanced iteration patterns and helpers.
//
// # Construction
//
// [Chars] returns an iterator sequence over the runes in the given byte slice.
//
//	func Chars(b []byte) iter.Seq[rune]
//
// [Cycle] repeats an iterator endlessly.
//
//	func Cycle[T any](x iter.Seq[T]) iter.Seq[T]
//
// [Empty] creates an iterator that yields nothing.
//
//	func Empty[T any]() iter.Seq[T]
//
// [FromIndex] returns an infinite iterator of numbers starting from the given index n.
//
//	func FromIndex[T Number](n T) iter.Seq[T]
//
// [FromIndexBy] returns an iterator of values generated by repeatedly applying the given function f to an initial value.
//
//	func FromIndexBy[T Number](n T, f func(T) T) iter.Seq[T]
//
// [FromChan] returns an iterator that yields values from the provided channel ch.
//
//	func FromChan[T any](ch <-chan T) iter.Seq[T]
//
// [Iterate] creates an infinite iterator by repeatedly applying the given function f to the initial value init.
//
//	func Iterate[T any](init T, f func(T) T) iter.Seq[T]
//
// [Once] creates an iterator that yields an element exactly once.
//
//	func Once[T any](v T) iter.Seq[T]
//
// [OnceWith] creates an iterator that lazily generates a value exactly once by invoking the provided function f.
//
//	func OnceWith[T any](f func() T) iter.Seq[T]
//
// [Range] returns a sequence of numbers from start (inclusive) to stop (exclusive).
//
//	func Range[T Integer](start, stop T) iter.Seq[T]
//
// [RangeFrom] returns an infinite iterator of numbers starting from the given index start (inclusive).
//
//	func RangeFrom[T Integer](start T) iter.Seq[T]
//
// [RangeTo] returns a sequence of numbers from 0 (inclusive) to the given stop value n (exclusive).
//
//	func RangeTo[T Integer](stop T) iter.Seq[T]
//
// [Repeat] creates a new iterator that endlessly repeats a single element.
//
//	func Repeat[T any](e T) iter.Seq[T]
//
// [RepeatN] creates a new iterator that repeats a single element a given number of times.
//
//	func RepeatN[T any](e T, n int) iter.Seq[T]
//
// [RepeatWith] creates a new iterator that repeats elements of type T endlessly by applying the provided function f
//
//	func RepeatWith[T any](f func() T) iter.Seq[T]
//
// [Resource] emits an iterator of values for the given resource.
//
//	func Resource[S, T any](start func() (S, error), next func(S) (T, error), stop func(S)) iter.Seq[T]
//
// [Successors] creates a new iterator where each successive item is computed based on the preceding one.
//
//	func Successors[T any](v T, f func(T) (T, bool)) iter.Seq[T]
//
// # Mapping
//
// [Accumulate] makes an iterator that returns accumulated sums.
//
//	func Accumulate[T Number](x iter.Seq[T]) iter.Seq[T]
//
// [AccumulateBy] makes an iterator that returns accumulated results from other binary functions.
//
//	func AccumulateBy[T Number](x iter.Seq[T], f func(T, T) T) iter.Seq[T]
//
// [Chain] converts the arguments to iterators and links them together, in a chain.
//
//	func Chain[T any](x ...iter.Seq[T]) iter.Seq[T]
//
// [Chunks] splits the input sequence x into consecutive chunks of size n.
//
//	func Chunks[T any](x iter.Seq[T], n int) iter.Seq[[]T]
//
// [ChunkBy] groups consecutive elements from the input sequence x into slices,
// starting a new chunk each time the predicate function f returns true for an element.
//
//	func ChunkBy[T any](x iter.Seq[T], f func(T) bool) iter.Seq[[]T]
//
// [ChunkByKey] groups elements from the input sequence x into contiguous chunks,
// where each chunk contains consecutive elements that share the same key as determined by the function f.
//
//	func ChunkByKey[T any, B comparable](x iter.Seq[T], f func(T) B) iter.Seq[[]T]
//
// [Dedup] creates an iterator that only emits elements if they are different from the last emitted element.
//
//	func Dedup[T comparable](x iter.Seq[T]) iter.Seq[T]
//
// [DedupBy] creates an iterator that only emits elements if they are different from the last emitted element,
// as determined by the provided comparison function f.
//
//	func DedupBy[T any](x iter.Seq[T], f func(T, T) bool) iter.Seq[T]
//
// [DedupByKey] creates an iterator that only emits elements if they are different from the last emitted element.
//
//	func DedupByKey[T any, B comparable](x iter.Seq[T], f func(T) B) iter.Seq[T]
//
// [Enumerate] creates an iterator which gives the current iteration count as well as the next value.
//
//	func Enumerate[T any](x iter.Seq[T]) iter.Seq2[int, T]
//
// [Filter] creates an iterator which uses a function f to determine if an element should be yielded.
//
//	func Filter[T any](x iter.Seq[T], f func(T) bool) iter.Seq[T]
//
// [FilterMap] creates an iterator that both filters and maps.
//
//	func FilterMap[T, B any](x iter.Seq[T], f func(T) (B, bool)) iter.Seq[B]
//
// [Flatten] creates an iterator that flattens nested iterators.
//
//	func Flatten[T iter.Seq[V], V any](x iter.Seq[T]) iter.Seq[V]
//
// [Inspect] and writes the given item to the standard output.
//
//	func Inspect[T any](x iter.Seq[T], opts ...inspect.Option) iter.Seq[T
//
// [Intersperse] creates a new iterator which places a separator between adjacent items of the original iterator.
//
//	func Intersperse[T any](x iter.Seq[T], sep T) iter.Seq[T]
//
// [IntersperseWith] creates a new iterator which places an item generated by separator between adjacent items of the original iterator.
//
//	func IntersperseWith[T any](x iter.Seq[T], f func() T) iter.Seq[T]
//
// [Keys] returns an iterator of keys from the given iterator of key-value pairs.
//
//	func Keys[K, V any](x iter.Seq2[K, V]) iter.Seq[K]
//
// [Values] returns an iterator of values from the given iterator of key-value pairs.
//
//	func Values[K, V any](x iter.Seq2[K, V]) iter.Seq[V]
//
// [Swap] returns an iterator of value-key pairs from the given iterator of key-value pairs.
//
//	func Swap[K, V any](x iter.Seq2[K, V]) iter.Seq2[V, K]
//
// [Map] takes a function and creates an iterator which calls that function f on each element.
//
//	func Map[T, O any](x iter.Seq[T], f func(T) O) iter.Seq[O]
//
// [FlatMap] creates an iterator that works like Map, but flattens nested iterator.
//
//	func FlatMap[T, O any](x iter.Seq[T], f func(T) iter.Seq[O]) iter.Seq[O]
//
// [MapWhile] creates an iterator that both yields elements based on a predicate f and maps.
//
//	func MapWhile[T, O any](x iter.Seq[T], f func(T) (O, bool)) iter.Seq[O]
//
// [Pairs] returns an iterator of pairs from the given iterator of key-values.
//
//	func Pairs[K, V any](x iter.Seq2[K, V]) iter.Seq[tuple.Tuple2[K, V]]
//
// [Unpairs] returns an iterator of key-values from the given iterator of pairs.
//
//	func Unpairs[K, V any](x iter.Seq[tuple.Tuple2[K, V]]) iter.Seq2[K, V]
//
// [Partition] takes an iterator of values and a predicate function f,
// and returns two slices containing the values for which the predicate returned true of false.
//
//	func Partition[T any](x iter.Seq[T], f func(T) bool) tuple.Tuple2[iter.Seq[T], iter.Seq[T]]
//
// [Pipeline] applies the given Mapper functors to the input sequence in order.
//
//	func Pipeline[T any](s iter.Seq[T], x ...Mapper[T, T]) iter.Seq[T]
//
// [Scan] applies the provided function f to each element in the input iterator x,
// yielding a new iterator of the results of applying f.
//
//	func Scan[C, T, B any](x iter.Seq[T], ctx C, f func(C, T) (B, bool)) iter.Seq[B]
//
// [Skip] creates an iterator that skips the first n elements.
//
//	func Skip[T any](x iter.Seq[T], n int) iter.Seq[T]
//
// [SkipWhile] creates an iterator that skips elements based on a predicate f.
//
//	func SkipWhile[T any](x iter.Seq[T], f func(T) bool) iter.Seq[T]
//
// [StepBy] creates an iterator starting at the same point, but stepping by the given amount at each iteration.
//
//	func StepBy[T any](x iter.Seq[T], n int) iter.Seq[T]
//
// [Take] creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.
//
//	func Take[T any](x iter.Seq[T], n int) iter.Seq[T]
//
// [TakeWhile] creates an iterator that yields elements based on a predicate f.
//
//	func TakeWhile[T any](x iter.Seq[T], f func(T) bool) iter.Seq[T]
//
// [Uniq] creates a stream that only emits elements if they are unique.
//
//	func Uniq[T comparable](x iter.Seq[T]) iter.Seq[T]
//
// [UniqByKey] creates a stream that only emits elements if they are unique,
// by removing the elements for which function fun returned duplicate elements.
//
//	func UniqByKey[T any, B comparable](x iter.Seq[T], f func(T) B) iter.Seq[T]
//
// [Zip] converts the arguments to iterators and zips them.
//
//	func Zip[K, V any](k iter.Seq[K], v iter.Seq[V]) iter.Seq2[K, V]
//
// [ZipWith] takes two iterators and a function, and returns a new iterator that
// applies the function to the corresponding elements of the input iterators and yields the results.
//
//	func ZipWith[K, V, B any](k iter.Seq[K], v iter.Seq[V], f func(K, V) B) iter.Seq[B]
//
// [Unzip] converts an iterator of key-values into a pair of containers.
//
//	func Unzip[K, V any](x iter.Seq2[K, V]) tuple.Tuple2[iter.Seq[K], iter.Seq[V]]
//
// # Reduction
//
// [All] returns true if all elements in the provided sequence x satisfy the predicate function f.
//
//	func All[T any](x iter.Seq[T], f func(T) bool) bool
//
// [Any] returns true if any element in the provided sequence x satisfies the predicate function f.
//
//	func Any[T any](x iter.Seq[T], f func(T) bool) bool
//
// [Compare] compares the elements of tow iterators.
//
//	func Compare[T cmp.Ordered](l, r iter.Seq[T]) int
//
// [CompareBy] compares the elements of tow iterators with respect to the specified comparison function f.
//
//	func CompareBy[T any](l, r iter.Seq[T], f func(T, T) int) int
//
// [Count] returns the number of iterations.
//
//	func Count[T any](x ...iter.Seq[T]) (n int)
//
// [Find] searches for an element of an iterator that satisfies a predicate f.
//
//	func Find[T any](x iter.Seq[T], f func(T) bool) opt.Option[T]
//
// [FindMap] applies function f to the elements of iterator and returns the first result that satisfies a predicate f.
//
//	func FindMap[T, B any](x iter.Seq[T], f func(T) (B, bool)) opt.Option[B]
//
// [First] returns the first element.
//
//	func First[T any](x iter.Seq[T]) opt.Option[T]
//
// [Fold] folds every element into an accumulator by applying an operation f, returning the final result.
//
//	func Fold[T, B any](x iter.Seq[T], init B, f func(B, T) B) B
//
// [ForEachFunc] calls a function f on each element of an iterator.
//
//	func ForEach[T any](x iter.Seq[T], f func(T))
//
// [GroupBy] makes a map that returns consecutive keys and groups from the sequence.
//
//	func GroupBy[T comparable](x iter.Seq[T]) map[T][]T
//
// [GroupByKey] groups elements from the provided sequence `x` into a map based on a key generated by the function `f`.
//
//	func GroupByKey[T any, K comparable](x iter.Seq[T], f func(T) K) map[K][]T
//
// [IsSorted] reports whether x is sorted in ascending order.
//
//	func IsSorted[T cmp.Ordered](x iter.Seq[T]) bool
//
// [IsSortedBy] reports whether x is sorted in ascending order using the given comparator function.
//
//	func IsSortedBy[T any](x iter.Seq[T], f func(T, T) bool) bool
//
// [IsSortedByKey] reports whether x is sorted in ascending order using the given key extraction function.
//
//	func IsSortedByKey[T any, B cmp.Ordered](x iter.Seq[T], f func(T) B) bool
//
// [Last] returns the last element.
//
//	func Last[T any](x iter.Seq[T]) opt.Option[T]
//
// [Max] returns the maximum element of an iterator.
//
//	func Max[T cmp.Ordered](x iter.Seq[T]) (r T)
//
// [MaxBy] returns the element that gives the maximum value with respect to the specified comparison function.
//
//	func MaxBy[T any](x iter.Seq[T], f func(T, T) int) (r T)
//
// [MaxByKey] returns the element that gives the maximum value from the specified function.
//
//	func MaxByKey[T any, B cmp.Ordered](x iter.Seq[T], f func(T) B) (r T)
//
// [Min] returns the minimum element of an iterator.
//
//	func Min[T cmp.Ordered](x iter.Seq[T]) (r T)
//
// [MinBy] returns the element that gives the minimum value with respect to the specified comparison function.
//
//	func MinBy[T any](x iter.Seq[T], f func(T, T) int) (r T)
//
// [MinByKey] returns the element that gives the minimum value from the specified function.
//
//	func MinByKey[T any, B cmp.Ordered](x iter.Seq[T], f func(T) B) (r T)
//
// [Next] returns the next value.
//
//	func Next[T any](s iter.Seq[T]) opt.Option[T]
//
// [Nth] returns the nth element of the iterator.
//
//	func Nth[T any](x iter.Seq[T], n int) opt.Option[T]
//
// [Position] searches for an element in an iterator, returning its index, or -1 if not present.
//
//	func Position[T any](x iter.Seq[T], f func(T) bool) int
//
// [Produce] iterates over the entire iterator, multiplying all the elements
//
//	func Product[T Number](x iter.Seq[T]) (p T)
//
// [Reduce] reduces the elements to a single one, by repeatedly applying a reducing operation f.
//
//	func Reduce[T any](x iter.Seq[T], f func(T, T) T) (r T)
//
// [Sum] sums the elements of an iterator.
//
//	func Sum[T Number](x ...iter.Seq[T]) (r T)
//
// [SumBy] sums the element that gives the value from the specified function.
//
//	func SumBy[T any, B Number](x iter.Seq[T], f func(T) B) (r B)
package xiter
